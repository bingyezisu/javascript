<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="div1"></div>
<script>
    //1、typeof 用来检测数据类型的运算符
    /*console.log(typeof 12);
    var num="zhufeng";
    console.log(typeof num);*/
    //->使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串中包含了对应的数据类型
    //例如："number" "string" "boolean","undefined","function","object"
    //局限性：
    //->typeof null->"object"
    //->不能具体的细分是数组还是正则，还是对象中的其他的值，因为使用typeof检测数据类型，对于对象数据类型中的所有的值，最后返回的结果都是“object”

    //2、instanceof 检测某一个实例是否属于某一个类
/*    var obj=[12,23];
    console.log(obj instanceof Array);//true
    console.log(obj instanceof RegExp);//false*/
    //->局限性
    //1、不能又来检测和处理字面量方式创建出来的基本数据类型值
    //->对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototype上提供的方法
    //console.log(1 instanceof Number);//false
    //console.log(new Number(1) instanceof Number);//true
    //2、instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是ture
/*    var ary=[];
    console.log(ary instanceof Array);
    console.log(ary instanceof Object);
    function fn(){

    }
    console.log(fn instanceof Function);//true
    console.log(fn instanceof Object);//true*/
    var oDiv=document.getElementById("div1");
    //oDiv->HTMLDivElement.prototype->HTMLElement.prototype->Element.prototype->Node.prototype->EventTarget.prototype->Object.prototype
    //console.log(oDiv instanceof EventTarget);//true
    function fn(){

    }
    Fn.prototype=new Array();//->原型继承 让子类的原型等于父类的一个实例
    var f=new Fn;

    //3、constructor 构造函数
    //4.Object.prototype.toString.call()
</script>
</body>
</html>