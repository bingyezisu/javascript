<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
   /* Function.prototype.myCall=function (context){
        //myCall方法中的this就是当前我要操作和改变其this关键字的那个函数名

        //->1.让fn中的this关键字变为context的值->obj
        //->让this中的这个函数的"this关键字"变为context
        //eval(this.toString().replace("this","obj"));

        //->2.让fn方法在执行
        this();
    }*/
   function fn1(){console.log(1)};
   function fn2(){console.log(2)};
   fn1.call(fn2);//->首先fn1通过原型链截止找到Function.prototype上的call方法，并且让call方法执行->此时call这个方法中的this就是我要操作的fn1->在call方法代码执行的过程中首先让fn1中的this关键字变为fn2，然后在fn1这个方法执行->1
   fn1.call.call(fn2);//->fn1.call首先fn1通过原型链找到Function.prototype上的call方法，然后在让call方法通过原型在找到Function原型上的call（因为call本身的值也是一个函数，所以同样可以找到Function.prototype），在第二次找到call的时候让方法执行，方法中的this是fn1.call,首先让这个方法中的this变为fn2，然后让fn.call执行->2
/*   function callFn(context){
       //->让this中的这个函数的"this关键字"变为context
       //->2.让fn方法在执行
       this();
   }
   Function.prototype.call=callFn;*/
   fn1.call.call(fn2);
   //fn1.call->Function.prototype.call->callFn
    //callFn.call(fn2)->先让call方法执行，call中的this是callFn，让callFn中的this变为fn2，再让callFn执行
    fn1.call.call.call.call.call(fn2);
    Function.prototype.call(fn1);
   Function.prototype.call.call(fn1);
</script>
</body>
</html>
</body>
</html>